Project Overview and Goals

Fortune Magnet is a personal development and goal-tracking web application with a focus on attracting wealth and success. It allows users to define their ‚Äúfortunes‚Äù ‚Äì these are personal goals or desired outcomes (for example, a financial goal, health target, or any life achievement) ‚Äì and helps track progress towards them. The app is designed with a luxury and motivational theme (‚ÄúLuxury Fortune Tracker ‚Äì Attract Wealth‚Äù) to inspire users. Key features include daily wellness check-ins, task management, progress tracking, and motivational achievements, all integrated to keep users engaged and moving toward their fortunes.

The ultimate goal of Fortune Magnet is to provide a centralized platform where users can create a fortune, work on it through actionable tasks, reflect on their journey daily, and gradually become a ‚Äúmagnet‚Äù for success. By combining goal tracking with habits and introspection, the app aims to foster consistency and positive mindset in achieving one‚Äôs ambitions.

Architecture Overview

Fortune Magnet‚Äôs architecture is divided into three main parts: a Supabase backend, a web frontend, and a mobile wrapper app.
	‚Ä¢	Supabase Backend: Supabase serves as the backend-as-a-service, providing a PostgreSQL database, authentication, file storage, and serverless functions (Edge Functions). All user data (accounts, profiles, fortunes, tasks, subscriptions, etc.) is stored in Supabase. Supabase Auth handles user sign-up and login (likely via email/password or OAuth providers), and row-level security rules ensure each user can only access their own data. Supabase Storage is used for storing uploaded images (fortune photos), and Edge Functions (written in TypeScript/Deno) implement custom logic like subscription webhooks, Stripe integration, and controlled file upload endpoints.
	‚Ä¢	Web Application (Frontend): The main client is a web app built with React + TypeScript (using Vite for bundling). This is the primary interface where users interact with Fortune Magnet. The web app uses React Context and hooks for state management (e.g. SubscriptionContext for subscription status, TutorialContext for onboarding, etc.), and libraries like React Router (for navigation between pages), TanStack React Query (for data fetching and caching), and UI component libraries for a polished look (possibly a custom or ShadCN UI components as indicated by references to components/ui/*). The web frontend is deployed as a static site (for example, on Vercel at fortune-magnet.vercel.app). It communicates with Supabase directly (via Supabase JS client) for real-time data and queries.
	‚Ä¢	Mobile App (Native Wrapper): In addition to the web app, Fortune Magnet has companion mobile apps for iOS and Android built using Capacitor. The mobile app is essentially a WebView that loads the web application, ensuring a single codebase for core functionality. The Capacitor wrapper is configured to point to the production web URL, so users on mobile get the same React app experience within a native container. This native layer is lightweight but crucial for enabling certain features:
	‚Ä¢	Push Notifications: The native app will integrate with iOS/Android notification services to send reminder notifications (e.g. daily reminders to update progress or complete the wellness survey). This isn‚Äôt possible from the web alone, so the native wrapper will handle scheduling and receiving push notifications.
	‚Ä¢	Native Photo Upload: Attaching images to fortunes is restricted to native apps. The mobile app can leverage device capabilities (camera and photo gallery) to let users select or capture images. These images are then uploaded to Supabase Storage via secure endpoints. The web app UI is aware of this ‚Äì the ‚Äúadd photo‚Äù option only appears when running in the native context.
	‚Ä¢	The native app may also handle other native-only features in the future (e.g. biometric login, offline storage), but its primary role is to bridge the gap between web and device features while reusing the web UI.

By using a web-first approach with a native wrapper, Fortune Magnet‚Äôs architecture achieves cross-platform consistency and ease of maintenance (one core application), while still offering enhanced functionality on mobile devices where it makes sense.

Key Features and Functionality
	‚Ä¢	Fortune Creation & Tracking: Users can create new ‚Äúfortunes‚Äù which represent goals or outcomes they want to attract/achieve. Creating a fortune typically involves providing a description (text of what you want to achieve) and selecting a category. Categories can be things like Wealth, Health, Love, Opportunity, etc., which help organize fortunes. Each fortune can also be given an icon or symbol for quick recognition (e.g. a trophy icon for an achievement, a dollar sign for a money goal, etc.). Fortunes have a creation date and possibly a ‚Äúfortune level‚Äù or impact indicator. (In the app‚Äôs current model, fortunes themselves do not have a numeric target or percentage progress by default ‚Äì they are more like containers for related tasks and reflections. Numeric progress tracking might be added for certain categories, but initially progress is tracked via tasks completed and personal growth indicators.)
	‚Ä¢	Task Management (Kanban Board): Fortune Magnet includes a personal task board to manage steps or tasks, which can indirectly support achieving fortunes. Users can create tasks (to-do items) and mark them as ‚ÄúTo Do‚Äù, ‚ÄúIn Progress‚Äù, or ‚ÄúDone‚Äù (a basic Kanban workflow). The tasks feature is integrated into the app so that users can break down their fortunes into actionable steps. Tasks are stored separately (each task has a title, an icon, status, and timestamps for creation/completion). In the current implementation, tasks are not yet explicitly linked to specific fortunes ‚Äì they function as a general to-do list for the user‚Äôs overall journey. (Linking tasks to a fortune could be a future improvement.) The Task Board UI provides an overview of all ongoing tasks and their statuses, allowing users to update progress (move tasks to ‚Äúin progress‚Äù or ‚Äúdone‚Äù) and add new tasks as needed. This helps users take concrete actions towards their goals.
	‚Ä¢	Daily ‚ÄúKnow Myself‚Äù Wellness Survey: A premium feature of Fortune Magnet is a daily self-reflection survey (nicknamed Know Myself). This is an interactive modal/wizard that asks the user a series of questions each day ‚Äì for example, questions about their mood, habits, or reflections related to their goals. The idea is to promote self-awareness and a daily check-in routine. Users with access to this feature can fill out the survey once per day, and the app may provide insights or just record the responses for the user‚Äôs personal tracking. This survey is only accessible to users with a subscription or during the free trial (it‚Äôs treated as a ‚Äúpremium‚Äù feature). If a free user (outside of trial) attempts to use it, the app will prompt them to upgrade (e.g. ‚ÄúUpgrade to Pro or Lifetime to access the daily wellness survey‚Äù). The inclusion of this feature is meant to encourage daily engagement and mindful progress towards fortunes, beyond just task completion.
	‚Ä¢	Progress and Insights: The app provides an Insights dashboard that gives users an overview of their progress and usage. This includes statistics like number of fortunes created, tasks completed, streaks of daily check-ins, etc. It also includes an Achievements system: there are milestone achievements (e.g. ‚ÄúFirst Fortune‚Äù for creating the first goal, ‚ÄúFortune Seeker‚Äù for creating 10 goals, etc.) that users can unlock. Achievements are displayed with titles, descriptions, and icons (for example, a target icon for first fortune, a magnifying glass for 10 fortunes, etc.), and they serve to gamify the experience and reward the user‚Äôs engagement. In the current version, achievements are mostly illustrative ‚Äì the app can calculate which ones the user has earned (based on counts of fortunes or other criteria), and show which are unlocked vs locked. Future iterations might persist achievements or add more complex ones, but even at MVP, this feature gives positive reinforcement to the user.
	‚Ä¢	Image Attachments for Fortunes: Users can add a photo to each fortune to better visualize their goal (for instance, an image of a dream house for a ‚Äúbuy a house‚Äù fortune, or a vision board picture related to the goal). However, this feature is only available on the native mobile apps ‚Äì the web app interface does not support uploading images. This decision was made for both user experience and security reasons. On mobile, users can quickly snap a photo or choose from their gallery, which is more natural for this kind of app. On the web, image uploading is disabled/not shown (even if a user is premium) to keep the web interface streamlined and to prevent large file uploads from desktop. Under the hood, when a mobile user opts to attach a photo, the app will use a native file picker or camera, then upload the image to Supabase Storage (to a protected bucket). Each fortune can have one associated image stored in the database (in a fortune_media table with fields like fortune_id, path, etc.). The app will display the fortune‚Äôs image in the UI (with appropriate caching or a signed URL from Supabase). If the user is not premium (no active subscription or trial), the option to add a photo is not available at all ‚Äì it‚Äôs considered a premium capability.
	‚Ä¢	Reminders and Notifications: To help users stay consistent, Fortune Magnet plans to send reminder notifications. For example, the app might send a daily push notification at a set time reminding the user to fill out their daily survey or update progress on their fortunes. These notifications are handled by the native app (since web push notifications support is limited and not as reliable for this use case). The mobile wrapper will register for push notifications (likely using Firebase Cloud Messaging on Android and APNs on iOS) and schedule local reminders. In the current state of the project, the notification system is in development ‚Äì the groundwork (permissions and app configuration) is laid in the native app, but scheduling of actual reminders may be completed as a next step. Users can expect that in the MVP release, they will receive simple daily reminders (especially if they have pending tasks or haven‚Äôt checked in that day), which can greatly improve engagement.
	‚Ä¢	User Profile and Settings: Each user has a profile that stores basic information like display name and avatar. The app provides a settings panel (a slide-out drawer) where users can potentially edit their profile, switch themes, and configure preferences. For example, Fortune Magnet supports light and dark themes (using next-themes library), so users can toggle between a clean light mode and a luxurious dark mode with gold accents. The settings drawer also includes options like exporting data (not yet implemented, currently shows ‚ÄúComing Soon‚Äù for data export) and viewing account details. From the settings, a user can log out as well. In the future, more settings may be added (such as notification time preferences, language selection, etc.).

Subscription Model and Premium Access

Fortune Magnet uses a freemium model with a subscription upgrade (Pro/Premium plans) for advanced features. The subscription logic is as follows:
	‚Ä¢	Free Trial Period: New users start with a generous free trial. For the first 60 days after signup (or until a certain usage limit is reached), a user has full access to all features as if they were a premium user. During this trial, they can create up to 100 fortunes without any feature restrictions. This lets users fully experience the app‚Äôs capabilities (including adding images via mobile, using the daily survey, etc.) before deciding to subscribe. The app tracks trial status by comparing the account age (or a trial_ends_at timestamp in the profile) and the number of fortunes. As long as the user is within 60 days of signup and under the 100 fortune limit, they are considered in trial (active trial status = true).
	‚Ä¢	Post-Trial Free Tier Limitations: Once the trial expires (after 60 days) or the user has created 100 fortunes (whichever comes first), the account reverts to the Free plan limitations. Free users can still use the app indefinitely but with restricted capacity:
	‚Ä¢	They can only add 1 new fortune per day (daily limit). If they try to add more on the same day, the app will prevent it and show a message (e.g. ‚ÄúYour free plan now limits you to 1 fortune per day.‚Äù). This encourages upgrading for heavier usage.
	‚Ä¢	Certain features become inaccessible to free users: for example, the Know Myself daily survey becomes locked (shows an upgrade prompt), and fortune images cannot be added (the backend will refuse image uploads without a subscription or trial). Essentially, premium features are turned off once the trial is over.
	‚Ä¢	Other possible free limits include a cap on how many categories the user can have or other advanced stats, although the primary enforced limits are the daily fortune creation and feature access.
	‚Ä¢	Subscription Plans: Fortune Magnet offers paid plans to unlock full functionality permanently:
	‚Ä¢	Pro (Monthly/Annual): This is a subscription plan (for example, $9.99 monthly or $99.99 yearly). Pro subscribers get unlimited access ‚Äì no daily limits on adding fortunes, and full use of all premium features (images, daily survey, unlimited task usage, etc.). Essentially, it continues the experience they had during trial. The yearly plan is offered at a discount (roughly 2 months free compared to monthly).
	‚Ä¢	Lifetime (One-Time): For users who prefer a one-time purchase, there is a Lifetime access plan (a higher one-time fee that grants permanent premium access without any recurring payments). This might be labeled as a ‚ÄúPremium Lifetime‚Äù plan in the app. Lifetime users are treated the same as subscribers in terms of access.
	‚Ä¢	(Potential Premium Tier): In the code there are references to a ‚ÄúPremium‚Äù plan tier in addition to ‚ÄúPro‚Äù. This suggests that the team considered offering two levels of paid plans (e.g., Pro vs Premium) ‚Äì perhaps with Premium being a higher tier with extra perks. However, as of now, the primary distinction is between free (trial/expired) vs paid (Pro). It‚Äôs possible that ‚ÄúPremium‚Äù is an alias for the lifetime plan or an early-bird promotional plan. For the current scope, ‚ÄúPro‚Äù and ‚ÄúPremium‚Äù can be seen collectively as the paid level. Any user with an active subscription (monthly/yearly) or lifetime purchase is considered a premium user in the app and will have full features.
	‚Ä¢	Early-Bird Promotions: During the initial launch, Fortune Magnet may run an ‚ÄúEarly Bird‚Äù offer for early adopters. This is indicated by flags like is_early_bird on plans. Early bird plans are special discounted variants of the regular plans (for example, a lower price for the first year or a cheaper lifetime price) available to users who subscribe during their trial period. The app dynamically checks if a user is eligible for an early-bird discount (typically: user is still in trial and hasn‚Äôt redeemed an early-bird offer yet). If so, the pricing page will show ‚ÄúFounders‚Äô Price‚Äù badges on the annual/lifetime plans to entice the user to upgrade before the trial ends. These promotional plans are handled by the backend (Supabase has a plans table with entries marking which are early bird offers) and by the frontend logic (replacing standard plans with early-bird versions if the user qualifies). This strategy rewards engaged new users with a limited-time deal.
	‚Ä¢	Subscription Management: All subscription purchases and payments are processed via Stripe integration:
	‚Ä¢	The app uses Supabase‚Äôs Stripe integration (managed through functions and webhooks). When a user chooses a plan and clicks ‚ÄúSubscribe‚Äù, the frontend will call a Supabase Edge Function (e.g. create-checkout-session) which creates a Stripe Checkout Session for the selected plan price and returns a URL. The user is then redirected to Stripe‚Äôs hosted checkout to enter payment details securely.
	‚Ä¢	After payment, Stripe triggers a webhook (stripe-webhook function in Supabase) which updates the Supabase database ‚Äî creating or updating the user‚Äôs subscription record, setting their status to active, storing the next renewal date, etc. The app listens for these changes (or polls) and reflects the new premium status in the UI.
	‚Ä¢	Users can also manage their subscription (update payment method, cancel, etc.) via a Customer Portal link (another function create-portal-session that generates a Stripe billing portal URL).
	‚Ä¢	The app‚Äôs SubscriptionContext and backend logic together determine if isActive subscription exists for the user at any time, and if so, the user is granted premium access immediately.
	‚Ä¢	If a subscription lapses or is canceled, the user reverts to free restrictions (though possibly with grace until their current period ends).
	‚Ä¢	The system also accounts for lifetime access (which is essentially a subscription with no end date or a special flag is_lifetime=true in the subscription record).

In summary, free users (after trial) can still use Fortune Magnet with basic functionality, but subscribers (Pro or Lifetime) get the full, unrestricted experience: unlimited fortune creation, daily wellness surveys, image uploads, advanced insights, and any new premium features that will be added. The subscription model is built to be flexible and handled through Supabase+Stripe, making it easy to adjust pricing or plans if needed.

Typical User Flow
	1.	Onboarding & Signup: A new user downloads the Fortune Magnet app or visits the web app and is prompted to sign up. Account creation is handled through Supabase Auth ‚Äì the user can register with an email and password (and possibly OAuth options like Google if enabled). Once signed up, a new profile is created for them in the database and their free trial countdown begins. The app might show a brief tutorial or welcome modal (explaining key features and encouraging the user to start their first fortune).
	2.	Creating a Fortune: The user‚Äôs first task is to create a fortune (goal). They tap the ‚ÄúNew Fortune‚Äù button (often represented with a ‚Äú+‚Äù or similar icon in the UI). A modal window opens (the FortuneModal) where they can input the details:
	‚Ä¢	Text/Title: a description of what they want to achieve or attract. This could be a short phrase or a sentence (e.g. ‚ÄúSave $10,000 for emergency fund‚Äù or ‚ÄúRun a marathon next year‚Äù or ‚ÄúFind a new job I love‚Äù ‚Äì any personal fortune).
	‚Ä¢	Category: choose an appropriate category like Wealth, Health, Love, Opportunity, etc. Categories help categorize fortunes; each category might have a color or icon associated for visual distinction. (If the user doesn‚Äôt find a fitting category, ‚ÄúOther‚Äù can be used. Free users might be limited in number of categories they can use or custom categories might be a paid feature ‚Äì for now, categories are predefined).
	‚Ä¢	Icon/Impact Level: optionally, select an icon or an ‚Äúimpact level‚Äù for the fortune. The app provides a set of icons (üéØ, üèÜ, üíñ, üí∞, etc.) that the user can pick to represent the fortune. These icons correspond to how significant or what type of fortune it is (this is mostly for personalization; impact level might internally just note how big the goal is).
	‚Ä¢	The user saves the fortune. It now appears in their Fortune List ‚Äì a scrollable list or grid of all their fortunes (likely on the home screen of the app). Each fortune card shows the title, category icon/color, perhaps creation date, and maybe a placeholder for progress or image.
	3.	Updating Progress & Using Features:
	‚Ä¢	Daily Check-In: Each day, the user can use the Know Myself survey (if they have access) to log their mindset or reflect on their journey. For example, they might rate their motivation level, answer a prompt about gratitude or accomplishments of the day. After completing the survey, the day‚Äôs check-in is marked done. This routine helps the user stay engaged with their fortunes consistently.
	‚Ä¢	Adding Tasks: The user can break down fortunes into tasks. They go to the Tasks section (perhaps accessible via a tab or a button like ‚ÄúTask Board‚Äù). Here they can add tasks (e.g. ‚ÄúOpen savings account‚Äù if the fortune is saving money, or ‚ÄúRun 5km this week‚Äù for a marathon goal). New tasks start as ‚ÄúTo Do‚Äù. The user can drag-and-drop tasks between columns (To Do ‚Üí In Progress ‚Üí Done) or use buttons to update status. Over time, as tasks are completed (moved to Done), the user sees tangible progress. Completed tasks might also be counted towards achievements (like ‚Äú10 tasks completed‚Äù achievement).
	‚Ä¢	Attaching a Photo: If the user is on mobile and has a premium status (trial or subscribed), they can attach an inspirational image to a fortune. They would open the fortune (maybe tapping on the fortune card to view details) and use an ‚ÄúAdd Photo‚Äù option. This triggers the device‚Äôs image picker or camera. After the user selects or takes a picture, the app uploads it to the backend. Once uploaded and processed, the fortune card now shows a thumbnail of that image. This visual can serve as a vision-board element, keeping the user motivated. (For example, seeing a picture of a dream house each time they open the ‚ÄúBuy a house‚Äù fortune).
	‚Ä¢	Tracking Results: The fortunes themselves might not have a numeric progress bar in this MVP, but progress is implicitly tracked via tasks done and days checked in. The user can mark a fortune as achieved once they feel it‚Äôs completed (this could be done by perhaps a button like ‚ÄúMark as Achieved‚Äù ‚Äì which might archive the fortune or highlight it). Achieved fortunes could be moved to a separate section or marked with a trophy icon. (If not implemented yet, achieved state may be a planned feature.)
	4.	Viewing Insights & Achievements: As the user continues to use the app:
	‚Ä¢	The Insights tab can be opened to view stats. For instance, a bar chart might show how many fortunes fall into each category (Wealth vs Health etc.), or how many tasks were completed this week. The user can identify where they spend most effort, and which areas might need more attention.
	‚Ä¢	Achievements: The app will show achievement badges for milestones. A new user will quickly get the ‚ÄúFirst Fortune‚Äù achievement after adding their first goal. As they add more, they might see a progress indicator like ‚Äú2/10 fortunes for Fortune Seeker‚Äù. When they hit 10 fortunes, that achievement unlocks. Similarly, there could be achievements for completing tasks, consecutive daily check-ins (a streak achievement), etc. The user can view a list of achievements (perhaps in the Insights or Profile section) to see what they‚Äôve earned and what‚Äôs next to earn, adding a fun, game-like element to the experience.
	5.	Subscription Upgrade Flow (if user chooses to subscribe):
	‚Ä¢	If a free user (trial expired) tries to use a premium feature (e.g. attempts to open the daily survey or add a 2nd fortune in one day), the app will show an Upgrade prompt ‚Äì likely a pop-up or an interstitial explaining the benefits of premium and providing a button to view plans.
	‚Ä¢	The user clicks ‚ÄúView Plans‚Äù which opens the Pricing page or dialog. Here, the available plans (Pro monthly, Pro annual, Lifetime) are displayed with their prices. If the user is still within an early-bird period, they will also see a special discounted price labeled as such.
	‚Ä¢	The user selects a plan (say, Annual Pro) and clicks ‚ÄúUpgrade‚Äù. The app then redirects them to a secure Stripe Checkout page (the app communicates with the Supabase function to get a Stripe session link behind the scenes). The user enters payment info and completes the purchase.
	‚Ä¢	After payment, when they return to the app, their account is now marked as premium. The UI will acknowledge this (perhaps ‚ÄúWelcome to Pro!‚Äù message). All limitations are lifted instantly: they can add unlimited fortunes, the daily limit warning disappears, premium features become available (the survey button now works, etc.). The app will also start the subscription perks such as allowing future image uploads (the next time they add a photo it will just work).
	‚Ä¢	From now on, the user can manage their subscription in Settings (via a ‚ÄúManage Subscription‚Äù link, which opens Stripe‚Äôs customer portal for upgrades or cancellation). If they ever cancel, they would keep premium status until the period ends, after which the app would revert them to free (maybe with another trial if they haven‚Äôt used the full trial before, but generally one trial per user).
	6.	Ongoing Usage: The user continues this cycle of adding fortunes, working on tasks, checking in daily, and so forth. Over time they might complete fortunes (which could then be logged as successes) and add new ones as life goals evolve. The app aims to become a daily companion in the user‚Äôs self-improvement or goal-achievement journey, making the process engaging and rewarding.
	7.	Exporting & Sharing (future considerations): The MVP plans to include an export feature so users can download a summary report of their data (all fortunes and progress). This isn‚Äôt implemented yet, but it‚Äôs envisioned as a way for users to keep their data or even share their progress with a coach or on social media. Similarly, future versions might allow sharing individual achievements or a fortune card as an image to inspire others (social features). These are not core to the MVP user flow but show the intended direction of the app.

Throughout the user flow, the design of Fortune Magnet emphasizes ease of use and positive reinforcement. The interface uses a clean layout with ‚Äúluxury‚Äù design elements (e.g., a dark theme with gold highlights) to give a premium feel. Tooltips, tutorials, and toasts guide the user (for example, a tooltip might highlight the Achievements section the first time, or a toast confirms ‚ÄúFortune added!‚Äù). The combination of goal tracking, task management, and reflective practice (survey) in one app is what makes Fortune Magnet a holistic tool for personal success.

Frontend Structure and Key Components

The front-end React application is organized into a modular structure with clearly defined components and contexts. Here are some of the key components and how the codebase is organized:
	‚Ä¢	Pages & Routing: The app uses React Router for navigation. The main routes are:
	‚Ä¢	/ (Home) ‚Äì shows the main application interface (fortune list, etc.) if logged in, or a landing/auth screen if not.
	‚Ä¢	/pricing ‚Äì a dedicated page or modal for the pricing plans and subscription upsell.
	‚Ä¢	A wildcard route for 404 Not Found.
The routing setup is defined in src/App.tsx, which wraps the app with providers (ThemeProvider, SubscriptionProvider, AuthProvider, etc.) and defines the Routes.
	‚Ä¢	Authentication: The component <AuthProvider> (in src/auth/AuthProvider.tsx) likely provides context for Supabase Auth state. It monitors if the user is signed in or not. In the UI, if no user session is present, the <AuthPage> component is rendered ‚Äì this would contain the UI for sign-in/sign-up (could be a custom form or Supabase UI component). When the user is logged in, the main app is shown instead.
	‚Ä¢	Main App Layout: The bulk of the logged-in interface is contained in src/components/FortuneApp.tsx. This component acts as the shell when a user is authenticated. It sets up the overall layout:
	‚Ä¢	A top navigation bar (<TopBar> component) ‚Äì this likely shows the app title/logo and maybe a menu or profile avatar icon that opens the settings.
	‚Ä¢	The main content area which could be divided into tabs or sections (e.g., fortunes list, insights, etc., possibly using an internal state or tabs).
	‚Ä¢	A hidden side drawer for settings (<SettingsDrawer> component), toggled via a button in the TopBar.
	‚Ä¢	It also ensures important contexts like subscription status (SubscriptionContext) are accessible to all child components.
	‚Ä¢	Fortune List & Modal:
	‚Ä¢	<FortuneList>: Displays the list of all fortunes the user has created. Each fortune might be represented by a card or list item showing its icon, title, category, and maybe a snippet of status (like number of tasks or an image thumbnail). FortuneList handles rendering all fortunes and possibly filtering or sorting them. It might also contain the button to add a new fortune.
	‚Ä¢	<FortuneModal>: A dialog for creating a new fortune or editing an existing one. Contains form fields for text, category dropdown, icon selection, etc. If editing an existing fortune and the user is premium on mobile, this modal might also show an option to attach/change the photo (since we saw logic gating photo upload). The FortuneModal handles validation and on submit, calls a Supabase function or direct insert to save the fortune. It likely uses a helper (possibly validate-and-insert-fortune edge function) to ensure the new fortune respects any limits (for free users, an edge function or RPC might check their current count and enforce limits).
	‚Ä¢	Task Board (Kanban):
	‚Ä¢	<TaskBoard>: Renders the three columns for tasks (To Do, In Progress, Done). It fetches the user‚Äôs tasks from the database (tasks table) and categorizes by status. Within each column, tasks are displayed using the <TaskItem> component.
	‚Ä¢	<TaskItem>: Represents an individual task card, showing its title and maybe an icon. Possibly allows drag-and-drop or has buttons to mark as complete. It might also show if a task is blocked or the date it was completed.
	‚Ä¢	The TaskBoard component interacts with Supabase (using supabase.from('tasks')) to read and update tasks. It uses React state or react-query to update the UI optimistically when tasks change status. (Note: Because tasks currently are not tied to fortunes, the task board likely shows all tasks. In future, filtering tasks per fortune or linking them might be added.)
	‚Ä¢	Know Myself Survey:
	‚Ä¢	<KnowMyselfModal> and <KnowMyselfWizard>: These components implement the daily wellness survey. The wizard is a sequence of steps/questions. Each step might be a question about the user‚Äôs day or mindset (for example: ‚ÄúHow do you feel today?‚Äù, ‚ÄúDid you accomplish what you intended today?‚Äù, etc., possibly with multiple-choice or rating scale).
	‚Ä¢	The state of the wizard (answers given, current step) is handled within these components or via a TutorialContext/KnowMyselfContext. Upon completion, the answers might be saved to Supabase (perhaps in a daily_reflections table or similar ‚Äì if not now, could be planned).
	‚Ä¢	Access control: The Luxury Avatar section in the UI (where the user‚Äôs profile avatar is shown in a glamorous style) is tied to the KnowMyself feature. The <LuxuryAvatarSection> component likely includes the avatar and if clicked, tries to open the KnowMyselfModal. It checks if (hasActiveSub) (meaning the user is premium) to decide whether to open the survey or show an ‚Äúupgrade‚Äù prompt. This way, free users (post-trial) clicking the avatar get an informative toast telling them this is a premium feature.
	‚Ä¢	Insights & Achievements:
	‚Ä¢	<InsightsTab>: A component or section that aggregates user data into visual insights. It might be part of a tabbed interface (for example, the main screen could have tabs for ‚ÄúFortunes‚Äù and ‚ÄúInsights‚Äù). In InsightsTab, the app could show graphs like a bar chart of fortunes by category, a line chart of fortunes added over time, etc. The code references an ImprovedStatistics component and use of chart libraries (perhaps Chart.js or similar).
	‚Ä¢	<ImprovedStatistics>: Likely a child of InsightsTab focusing on specific charts (maybe usage statistics). It might use a library for rendering a bar chart or pie chart. For instance, showing the proportion of tasks completed vs pending, or the breakdown of goals categories.
	‚Ä¢	<AchievementCard> and <AchievementsDetailModal>: These handle the achievements display. AchievementCard would show a single achievement badge (with icon, title, and whether it‚Äôs locked or earned). AchievementsDetailModal might pop up when an achievement is clicked to show a detailed description. The app likely has a predefined list of achievements (currently a static list in code, as ‚ÄúmockAchievements‚Äù), and a function calculates which are earned based on the user‚Äôs data (e.g., counts of fortunes or tasks).
	‚Ä¢	For now, achievements are not stored in the database individually; they are computed on the fly. In future, a persistent log of earned achievements could be saved, but at MVP the logic simply checks if criteria are met and displays accordingly.
	‚Ä¢	Billing & Upgrade UI:
	‚Ä¢	<PricingPage>: A standalone page that lists the subscription plans. It fetches plan details from Supabase (the plans table which contains plan names, levels, billing periods, and associated Stripe price IDs). It then calls an edge function get-prices to retrieve the current price amounts from Stripe, ensuring the UI shows up-to-date pricing (this way, pricing can be changed centrally in Stripe and reflected in the app).
	‚Ä¢	Plans are grouped by billing period (Monthly vs Annual), and there‚Äôs also a Lifetime plan. The UI likely has tabs for ‚ÄúMonthly vs Annual‚Äù with the Lifetime option shown in both or below. If the user is eligible for an early-bird discount, the PricingPage uses the earlyBirdEligible flag from SubscriptionContext to swap in the special pricing (early bird plans have is_early_bird = true in the database).
	‚Ä¢	<PricingDialog> / <PricingModal>: In some parts of the app (like when hitting a paywall feature), instead of navigating to the full PricingPage, a modal version might appear. This dialog shows a quick summary of the plans and a call-to-action to upgrade. It likely uses the same data sources as PricingPage. A TODO in the code indicates integrating the Stripe checkout link ‚Äì meaning when the user clicks an upgrade button, the app should call the create-checkout-session function and redirect to Stripe. This may be in progress, but the structure for it is in place.
	‚Ä¢	After returning from Stripe (post-checkout), the SubscriptionContext will detect the new subscription (possibly via an auth listener or polling). The app might also accept a return URL from Stripe and handle success (for example, Stripe can redirect to /?checkout_success=true, which the app could catch and trigger a refresh of subscription status).
	‚Ä¢	Miscellaneous Components:
	‚Ä¢	<TopBar>: Contains navigation controls, possibly the app title and a profile menu (avatar thumbnail that toggles Settings or shows the user‚Äôs name and a logout option).
	‚Ä¢	<SettingsDrawer>: A side drawer with various settings and options:
	‚Ä¢	Theme toggle (light/dark).
	‚Ä¢	Account info (maybe display email, and a ‚ÄúSign Out‚Äù button).
	‚Ä¢	Data export (currently just a placeholder ‚ÄúComing Soon‚Äù ‚Äì this will let users download their data as CSV or PDF in the future).
	‚Ä¢	Possibly a link to the subscription management if premium (like ‚ÄúManage Subscription‚Äù).
	‚Ä¢	Category manager (if users can customize or reorder categories, there might be a <CategoryManagerModal> referenced for managing custom categories ‚Äì in MVP this might not be fully needed as categories are preset, but the code structure is ready for it).
	‚Ä¢	<DevTools> or <DebugPanel>: There is a reference to a DebugPanel component in the code. This might be a development-only component that shows internal state (like whether the app thinks it‚Äôs running in native, or the values of certain context variables). For example, it logs if window.NativeUploaderAvailable is true/false, and other debug info. This would not be visible in production, but is useful during development to verify that native integration flags are set, etc.

The frontend code is structured in a way to separate concerns:
	‚Ä¢	Contexts (src/contexts): Manage global state like authentication, subscription, tutorial progress, etc., and provide hooks (useSubscription(), useFreePlanLimits(), etc.) to components.
	‚Ä¢	Integrations (src/integrations/supabase): Encapsulate direct Supabase calls or definitions (like the generated types for database, functions to get fortune media, subscription status, etc.). This helps keep data logic out of UI components.
	‚Ä¢	UI Components (src/components/ui): Likely contains reusable styled components (buttons, inputs, modals, tooltips). The presence of shadcn/Radix UI components (like <Button>, <Dialog>, <TooltipProvider>) suggests a consistent design system is used.
	‚Ä¢	Domain Components (src/components/*): These are specific to the app‚Äôs domain (FortuneApp, FortuneList, TaskBoard, Pricing, etc. as discussed). They are often composed of smaller UI components and business logic.
	‚Ä¢	Supabase Edge Functions (supabase/functions directory in the repo): Not part of the frontend per se, but the project keeps these serverless function codes versioned. They handle critical backend logic (billing, uploading, validation) that the frontend calls via HTTP. For example, the frontend will call POST /functions/v1/issue-fortune-upload-ticket when a user wants to upload a photo, or POST /functions/v1/create-checkout-session when starting a checkout.

Overall, the frontend is organized for maintainability, with a clear separation between UI, state management, and data fetching. This makes it easier for future contributors (or AI assistants) to quickly find where a certain logic resides (e.g. subscription checks in SubscriptionContext, free limits in useFreePlanLimits, etc.). The codebase is fully in TypeScript, with interfaces defining structures for things like Fortune, Task, Subscription, ensuring type safety across the app.

Supabase Database Schema (Inferred)

While the exact database schema is managed in Supabase, we can infer the key tables and their structure from the code:
	‚Ä¢	profiles: Each user has a profile row (often Supabase standard). Fields likely include:
	‚Ä¢	id (primary key, UUID, same as the auth user ID in many setups),
	‚Ä¢	user_id (also the auth user‚Äôs UID, possibly the same as id if they used a one-to-one setup),
	‚Ä¢	display_name (string, the user‚Äôs name/nickname),
	‚Ä¢	avatar_url (string, URL or path to profile picture if any),
	‚Ä¢	created_at and updated_at timestamps,
	‚Ä¢	stripe_customer_id (for linking to Stripe customer record),
	‚Ä¢	Trial fields: trial_ends_at (timestamp when free trial expires) or a boolean is_trial_active. The code references checking trial_ends_at to determine if the trial is still on. Also possibly early_bird_redeemed (boolean flag if the user already used the early-bird offer).
The user_features view mentioned in the code likely combines some of this profile info (like trial status or flags) for quick access in the app.
	‚Ä¢	fortunes: Stores each fortune (goal) the user creates.
	‚Ä¢	id (UUID),
	‚Ä¢	user_id (UUID reference to the user who owns it),
	‚Ä¢	text (text of the fortune ‚Äì the goal description or mantra, can be null if not provided but usually filled),
	‚Ä¢	category (text or enum, e.g. ‚ÄúWealth‚Äù, ‚ÄúHealth‚Äù, etc.),
	‚Ä¢	fortune_level (integer or smallint, possibly a legacy field or for future use to rank fortune‚Äôs importance),
	‚Ä¢	impact_level (string or enum, possibly reflecting the icon chosen or subjective impact like ‚ÄúHigh/Medium/Low‚Äù ‚Äì currently might mirror the icon selection, e.g., choosing a Crown icon might imply a certain impact level),
	‚Ä¢	fortune_value (numeric, nullable ‚Äì an older concept for a target value, not actively used in current logic but maybe kept for potential numeric goal tracking, like a target amount of money or weight),
	‚Ä¢	created_at (timestamp of creation).
Fortunes are likely protected by row-level security so only the owning user can select/update their fortunes. In addition, server-side validation (via a function validate-fortune-limits) may ensure a user doesn‚Äôt exceed certain number of fortunes if free, etc., when inserting.
	‚Ä¢	fortune_media: Stores metadata for fortune images (photos attached to fortunes).
	‚Ä¢	id (UUID),
	‚Ä¢	fortune_id (UUID reference to a fortune),
	‚Ä¢	user_id (UUID of owner, redundantly stored for easy RLS checks),
	‚Ä¢	bucket (text, e.g. ‚Äúphotos‚Äù indicating which storage bucket the file is in),
	‚Ä¢	path (text, the path/name of the file in the storage bucket),
	‚Ä¢	mime_type (text, e.g. ‚Äúimage/png‚Äù),
	‚Ä¢	width and height (integers, dimensions of the image in pixels),
	‚Ä¢	size_bytes (integer, file size),
	‚Ä¢	created_at, updated_at (timestamps).
When a user uploads a photo via the mobile app, an entry in this table is created (likely through the finalize-fortune-photo function after a successful upload). The image file itself is stored in Supabase Storage (bucket ‚Äúphotos‚Äù). The app can fetch the image for display by either making it public or (more securely) generating a signed URL when needed. For now, it seems the app uses a public URL for simplicity after upload, but the code also has capability to create short-lived signed URLs (which is more secure if the bucket is private).
	‚Ä¢	tasks: Stores the user‚Äôs tasks/to-do items.
	‚Ä¢	id (UUID),
	‚Ä¢	user_id (UUID owner),
	‚Ä¢	title (text for the task description),
	‚Ä¢	icon (text or emoji representing the task, if any icon is chosen ‚Äì possibly optional),
	‚Ä¢	status (enum text: ‚Äútodo‚Äù, ‚Äúin_progress‚Äù, or ‚Äúdone‚Äù),
	‚Ä¢	created_at (timestamp when task was made),
	‚Ä¢	blocked_at (timestamp if the task was blocked or put on hold, null if not used),
	‚Ä¢	completed_at (timestamp when marked done, null if not yet done).
The tasks table is straightforward. Currently there‚Äôs no fortune_id here, meaning tasks are general. It‚Äôs possible the design expects tasks to be more like daily habits or generic todos rather than tied strictly to one fortune, or it‚Äôs an MVP simplification. In the future, a fortune_id field could be added to link tasks to specific fortunes.
	‚Ä¢	subscriptions: Tracks subscription status for each user (likely populated via Stripe webhooks).
	‚Ä¢	id (UUID or Stripe subscription ID as primary key),
	‚Ä¢	user_id (UUID of the user),
	‚Ä¢	plan_id (UUID or slug referencing the plan chosen ‚Äì corresponds to an entry in the plans table),
	‚Ä¢	status (text, e.g. ‚Äúactive‚Äù, ‚Äúcanceled‚Äù, ‚Äúpast_due‚Äù, etc., directly mirroring Stripe subscription status),
	‚Ä¢	current_period_start and current_period_end (timestamps for the billing cycle window ‚Äì for recurring plans),
	‚Ä¢	is_lifetime (boolean, true if this subscription represents a lifetime access purchase; if true, current_period_end might be far future or null),
	‚Ä¢	Stripe-related fields: stripe_subscription_id (the Stripe subscription object ID), stripe_customer_id, stripe_price_id (the price identifier of the plan in Stripe that the user is subscribed to).
	‚Ä¢	created_at, updated_at (timestamps for record keeping).
This table is updated via the stripe-webhook function whenever events happen (subscription created, renewed, canceled). The app queries this table (often filtering by user_id and status) to determine if the user currently has an active subscription. Only one active subscription is expected per user (if any). If none is active and no lifetime flag, the user is considered free (or trial based on profile).
	‚Ä¢	plans: Defines the available subscription plans.
	‚Ä¢	id (UUID or short string identifier for the plan),
	‚Ä¢	name (e.g. ‚ÄúPro Monthly‚Äù, ‚ÄúPro Annual‚Äù, ‚ÄúLifetime Premium‚Äù, etc.),
	‚Ä¢	price_id (the Stripe Price ID corresponding to this plan‚Äôs pricing in Stripe),
	‚Ä¢	level (perhaps an integer or text indicating tier level ‚Äì e.g. 1 for Pro, 2 for Premium ‚Äì could be used to compare tiers),
	‚Ä¢	billing_period (text: ‚Äú28d‚Äù for monthly (4 weeks), ‚Äúannual‚Äù for yearly, ‚Äúlifetime‚Äù for one-time),
	‚Ä¢	is_early_bird (boolean, true if this is a special discounted early-bird plan),
	‚Ä¢	visibility (text: ‚Äúvisible‚Äù, ‚Äúhidden‚Äù, ‚Äúteaser‚Äù ‚Äì possibly to control if a plan is shown in UI; e.g., some legacy or test plans might be hidden, or a ‚Äúteaser‚Äù could be a plan displayed as upcoming or for certain users),
	‚Ä¢	other fields like price amount are not stored here (they are fetched from Stripe to ensure real-time accuracy).
The app loads plans from this table and then fetches live pricing info via the get-prices function. That function contacts Stripe with all the price_ids and returns details like unit amount (in cents), currency, interval (monthly or yearly), etc., which the frontend then uses to display pricing options to the user.
	‚Ä¢	user_features (database view): As mentioned, this likely combines the profiles and possibly subscription info for convenience. The SubscriptionContext fetches from user_features to get flags like is_trial_active and maybe some computed bools (like early_bird_eligible). The view might be defined as a SQL joining profiles and subscriptions with logic to set those flags (e.g., is_trial_active = true if profiles.trial_ends_at > now()).
	‚Ä¢	Edge Function Triggers: While not tables, it‚Äôs worth noting:
	‚Ä¢	validate-and-insert-fortune: This edge function probably acts as a secure way to add a new fortune. It could enforce the free user limits (checking how many fortunes the user has and if trial or not) before actually inserting the fortune. If the user is at limit, it would throw an error telling them to upgrade. Using such a function (instead of direct client-side insert) ensures the rules cannot be bypassed even if someone calls the Supabase API directly.
	‚Ä¢	validate-fortune-limits: Possibly a related function or trigger that ensures on every insert or update of fortunes, the count doesn‚Äôt exceed free limits (or maybe used by the above function).
	‚Ä¢	These functions supplement the RLS policies by adding business logic validation.
	‚Ä¢	Audit/Analytics tables: Not explicitly seen in code, but Supabase might also be used to track analytics events or logs. For instance, logging each daily survey entry, or storing aggregated stats. If present, these would be secondary and not critical for primary functionality (and might not be implemented yet).

All tables use UUIDs for identifiers and are secured so users can only manipulate their own records. The relationships between tables:
	‚Ä¢	profiles.user_id ‚Üí references auth users,
	‚Ä¢	fortunes.user_id ‚Üí references auth users (one-to-many: a user has many fortunes),
	‚Ä¢	fortune_media.fortune_id ‚Üí references fortunes (one-to-one effectively, since typically one image per fortune in current design),
	‚Ä¢	fortune_media.user_id ‚Üí references auth users (should match the fortune‚Äôs owner for security),
	‚Ä¢	tasks.user_id ‚Üí references auth users (one-to-many: user has many tasks),
	‚Ä¢	subscriptions.user_id ‚Üí references auth users (one-to-many, though normally one active at a time),
	‚Ä¢	subscriptions.plan_id ‚Üí references plans table,
	‚Ä¢	No direct link between tasks and fortunes in schema (tasks are global per user in MVP).

Additionally, Supabase‚Äôs Row-Level Security (RLS) policies would be in place on each of these tables to enforce that users can only select/update/delete their own data (identified by the user‚Äôs uid and the row‚Äôs user_id). For example, an RLS policy on fortunes might allow: user_id = auth.uid() for select and update, and something similar on tasks and fortune_media. The existence of dedicated edge functions for certain operations (like uploading images or inserting fortunes) suggests that some operations are further protected or require custom logic beyond basic RLS.

Current Status of the Project

As of now, Fortune Magnet is in an advanced prototype stage with many core features implemented, and a few key pieces nearing completion for MVP:
	‚Ä¢	Implemented Features:
	‚Ä¢	User authentication and profiles are working via Supabase. Users can sign up, log in, and the app maintains session state. Profile info (display name, avatar) is stored, and trial status is initialized for new users.
	‚Ä¢	Fortune creation and listing is fully functional. Users can add new fortunes (with text and category), see them in the list, and the data persists. Free/trial limitations on fortune count and daily additions are enforced (the UI and backend both have checks to prevent free users from adding beyond limits).
	‚Ä¢	Task management is operational. Users can create tasks and update their status. The UI shows tasks in a board layout for a clear overview of progress on various todos. Basic functions like marking tasks done and viewing incomplete tasks are in place.
	‚Ä¢	Daily survey (Know Myself) modal is implemented and integrated for premium users. The flow of questions and completion is working, although the question content may be placeholder or limited in this version. Trial/premium gating for this feature is in place (only accessible with subscription or active trial).
	‚Ä¢	Achievements and Insights dashboards are present. The app calculates some achievement milestones (like number of fortunes created) and displays which are earned vs locked. Insight charts for usage statistics are set up (e.g., using chart components to show data visually). These provide a foundation for more analytics, and even if some data is mocked currently, the structure allows real data to be plugged in easily.
	‚Ä¢	Theming and UI polish: The app has a polished UI kit with theming support (dark mode available). Many small details (icons, tooltips, loading spinners, toast notifications for user feedback) are handled to ensure a professional user experience.
	‚Ä¢	Mobile app integration: The Capacitor-based mobile apps have been created and configured. They successfully load the web app from the remote URL, meaning users on iOS/Android can use Fortune Magnet through these native wrappers. The basic integration points for native features are prepared (for example, the code has a mechanism to detect if it‚Äôs running inside the native app). In development mode, a mock uploader is used on web for testing image uploads, indicating that the infrastructure for real image uploading via native is ready to be connected.
	‚Ä¢	Image upload pipeline: On the backend, the storage and database for fortune photos is configured. The Supabase storage bucket photos is set up, and functions issue-fortune-upload-ticket and finalize-fortune-photo are implemented to securely handle image uploads. While the final connection from the mobile UI to these functions might still be in progress, the server-side logic to receive an image, validate permissions (ensure the user owns the fortune and is allowed to upload), and then record the image in the database is largely complete and tested. Once the mobile app calls these, images will be properly handled.
	‚Ä¢	Payment and subscription system: A lot of groundwork for subscriptions is in place. The app can display pricing pulled from Stripe, differentiate free vs paid user experience, and handle subscription records. The Stripe webhook integration on the backend is implemented to update subscriptions on events. The checkout and portal creation functions exist. This suggests that end-to-end testing of a subscription purchase is either done or very close ‚Äì a user can likely go through a test purchase and have their app access upgrade to premium. Any remaining work is likely around fine-tuning the UI flow (e.g., giving feedback after returning from Stripe checkout, etc.).
	‚Ä¢	General stability: The application logic for limiting free users, allowing trials, and ensuring premium features is quite comprehensive (covering many edge cases such as checking if a subscription just expired or if a new subscription is in process). This means the app is robust against state changes and should provide a smooth experience as the user transitions from trial to free or to paid.